##说说Kotlin和Java有什么区别

第一点，kotlin写法用法十分简洁，相对于java编程，kotlin有时可以用1行代码写出java二三十行代码的内容，例如：面向对象中java需要写构造方法，字段的get和set方法，toString方法等，kotlin定义的类会自动生成get和set方法，不需要像java那样人为导入，而且kotlin的data class 数据类，也可以自动生成toString方法，hashcode方法等，所以有时候定义data class 一行代码可以表达java很多行代码的内容，让代码显得干净整洁。

第二点，java只支持面向对象编程，而kotlin既支持面向对象也支持函数式编程，我认为kotlin是函数式编程为辅助工具的面向对象编程语言，java中所有的字段和方法必须定义在类中，包括主方法，万物皆对象，而kotlin中不用，主函数可以单独存在，对象和函数都是一等公民

第三点，kotlin的底层逻辑相比于java可能更加难以理解，比较明显的例子是高阶函数和lambda表达式，java暂时还没有高阶函数和lambda表达式的用法，更多的是通过易于理解的面向对象式的编程来实现需求，而kotlin可以通过高阶函数和lambda表达式将复杂的代码简写化，当然这带来的也会有理解难度上的问题。



##递归和迭代的区别

递归和迭代在算法上的区别（以求阶乘为例）：

递归的空间复杂度高为O(n)，而迭代的空间复杂度O(1) ，递归的时间复杂度和迭代的时间复杂度相同都为O(n)

所以，从阶乘的算法上来说迭代是明显优于递归的，包括在大多数应用中迭代算法都要比递归要好很多；

但递归在文件删除，树遍历等用法中有一个明显的优势：就是写法简单易懂；

所以递归可以在某些用迭代写起来很复杂但递归写起来很简单，而且数据量不大的情况下使用，但大多数情况下，还是优先考虑迭代



##抽象类和接口的区别

两者本质的区别：抽象类代表的是对象的本质，而接口代表的是对象的能力；一个子类只能继承一个父类，但可以实现多个接口，即一个子类的本质是固定的，但子类可以有很多其他的能力；

两者用法的区别：在java中，抽象类中的方法可以是抽象方法，也可以是非抽象方法，但接口中的方法只能是抽象方法；在kotlin中略有不同，接口也可以有非抽象方法，但正常情况下还是和java一样用法；

在使用中，一个非抽象类实现某接口时，接口中的抽象方法必须全部重写，由于某些抽象方法不一定会使用，所以实际开发中会用到适配器设计模式，每一个接口通过一个抽象类去实现，抽象类可以不用重写抽象方法，这样非抽象类只需要继承抽象类，而且不用重写接口中所有的抽象方法，可以选择性的重写。



##解释一下泛型和泛型擦除

泛型指的是在定义函数和类时，某些参数类型无法确定，使用Object类型（Any类型）时有些需求没办法达到，这时通过定义和使用泛型T来代表传入的参数类型；

kotlin中使用泛型时，可以使用" ："指定泛型上限，也可以通过in/out（协变和逆变）以及" * "来规定函数中传入的泛型参数的范围；

泛型擦除指的是在java中我们在获取一个带泛型的类的类型时，会自动将泛型擦除，例如ArrayList< String >,  ArrayList< Int > 通过getClass获取类名得到的结果都是ArrayList，所以在java中想要获取泛型类型需要通过十分复杂的反射来获取；但是在kotlin中我们可以通过reified和infine两个关键字可以较简单的获取传入的泛型的具体类型



##解释一下委托,以及他的作用

委托是一种设计模式，主要是指一个类将他的功能委托给另一个类代理，在java中主要是通过动态代理方法来实现，在kotlin中主要是通过by关键字来实现；

java中有很多重复操作，例如在ui类的方法中都需要加入权限校验和日志处理操作，这时可以通过动态代理将ui类委托给handler代理来完成重复操作；

kotlin中有类委托和属性委托两种，类委托是指把一个类A委托给另一个类B，调用A执行的任务都会调用B的相关方法，常用情况是A和B都实现某一个接口，B重写接口中的方法，A通过by关键字将接口中的方法委托给B代理，当有很多类需要实现该接口完成同样操作时，可以通过委托简化代码；属性委托是指将一个类A中的属性的get和set方法委托给另一个类B，B中必须有对应的getValue和setValue方法，当执行A属性的get和set操作时会调用B中的get和set方法，属性委托可以将属性中简单的取值和赋值操作赋予更多变化，例如A的money属性委托给B，A的money取值和赋值时，可以通过B的getValue和setValue方法对B中的属性做操作。



##列举一些你经常用到的高阶函数

foreach循环遍历

map 循环替换，将循环内的元素全部替换为lambda的返回值

flatMap 循环替换，和map类似，用在lambda返回值为一个集合时，将集合拆散；

groupBy 分组， 将循环内元素按lambda返回值条件分为两组，返回map集合

filter 过滤，将循环元素通过lambda返回值过滤，过滤掉返回值为false的元素

distinct 去重， distinct() 简单去重，distinctBy()

maxBy，minBy 最值，通过lambda返回值(例如age)来找到最大或最小的元素

apply 、let、with和run四大函数，可以通过四大函数解决多次空指针调用繁琐问题，kotlin通过四大函数可以更好的实现链式编程 



##说明一下接口回调和函数式回调

接口回调具体流程：

当一个对象需要完成一件事（妈妈买酱油），但没办法立即完成，可以创建一个完成任务的接口（买酱油能力），再创建一个具体类（儿子）实现该接口，重写完成任务的方法（传回酱油的方法），将该具体类的对象传给需要执行的函数（买酱油函数），在函数执行完后，具体类调用重写的方法完成任务（传回酱油）；

函数回调具体流程：

当一个对象需要完成一件事（妈妈买酱油），但没办法立即完成，可以不用创建接口和完成任务的类，只需要传入lambda表达式给需要执行的函数，该执行函数执行时调用传入的函数，完成任务（买酱油）。

在java中所有的方法都必须在类或接口中定义，所以需要一个接口来包装买酱油的方法；但在kotlin中函数的定义没有限制，可以通过传入定义的匿名函数来完成买酱油的任务。



##描述一下函数式编程有什么好处

函数式编程用法更加方便简洁，面向对象编程中，所有的属性字段和方法都必须定义在类中，因此某些情况下，需要特意为一个方法和字段创建一个类来包装，用起来比较复杂；函数式编程的好处是可以不受类的限制，函数可以定义在类中，也可以定义在类外（顶层函数），还可以通过匿名函数lambda表达式，简化函数间调用，更加符合简化代码的需求。



##什么是dsl, dsl有什么优点

DSL 是领域特定编程语言，例如Html和SQL；

dsl 的主要优点在于简单易学易懂，由于互联网的全球化，很多其他领域或其他方向需要用到IT技术来处理数据，而专业的编程语言对于某些非专业人员来说难学难懂，例如一个医院要把数据传入数据库中，就只需要看懂简单的SQL语言，很快就能进行操作；

在某些情况下，即便是专业的编程人员，由于水平不一，写出的代码水平可能不一样，可以编写一套简单易懂的DSL模板来规范编程人员的操作。



##gradle是什么,有什么用处

gradle是一种构建工具，我们主要用来构建环境和依赖，由于平时编程中有很多功能是kotlin或java自带包中没有的，但在网上能找到相应的三方jar包满足我们的需要，因此我们可以通过gradle方便的导入依赖的jar包，以及依赖jar包的下属依赖，方便我们管理依赖；

现在主流的两个构建工具是maven和gradle，gradle的使用者越来越多，gradle相比于maven来说构建速度更快，写法更加简洁

```
//gradle写法
dependencies {
 	compile 'org.hibernate:hibernate-core:3.6.7.Final'
	testCompile ‘junit:junit:4.+'
}


//maven写法
<dependency>
 <groupId>junit</groupId>
 <artifactId>junit</artifactId>
 <version>4.12</version>
 <scope>test</scope>
</dependency>
<dependency>
 <groupId>org.springframework</groupId>
 <artifactId>spring-test</artifactId>
</dependency>
```





##task的生命周期

task生命周期分为扫描生命周期和运行生命周期，task在运行前会对所有task进行顺序扫描，扫描时进入扫描生命周期，扫描完后开始运行，进入运行生命周期；

task中的代码例如开门任务中打印开门，是默认在扫描生命周期中执行；如果想要代码在运行生命周期中执行，需要用doFirst或doLast包裹。

```
//扫描生命周期执行
task("open door") {
    println("开门")
}

//运行生命周期执行
task("open door") {
    doFirst {
        println ("开门")
    }
}
```





##线程join有什么作用

线程join：一个线程ThreadA如果join加入另一个线程ThreadB，则ThreadB需要等到ThreadA执行完后才能开始执行，相当于将原来线程并行转化为串行。



##线程和协程的区别

线程和协程都是异步操作，它们的主要区别在于实现异步的原理不同；

几条线程实现异步操作，当开启的线程数大于CPU核数时，单位时间里只能有部分线程在执行操作，未抢占到资源的线程仍然占有线程，产生阻塞；

协程实现异步操作的底层仍然是通过线程池实现，但协程加入了挂起函数的概念，所有的挂起函数都可以被挂起，被挂起时线程可以回到线程池等待调用，等挂起结束后重新调用线程池中的空闲线程；协程是非阻塞的，在实际执行中同时开启大量同等数量的线程和协程比较，协程效率是普通线程的10倍左右。



##描述协程的工作原理 

协程实现异步操作的底层是默认通过线程池ForkJoinPool实现，ForkJoinPool创建的线程默认是守护线程，当用户线程都结束之后自动结束；

协程加入了挂起函数的概念，所有的挂起函数都可以被挂起，被挂起时线程可以回到线程池等待调用，等挂起结束后重新调用线程池中的空闲线程；挂起函数只能在协程和挂起函数中执行，因此为了能在主线程中调用挂起函数，可以通过runBlocking 将主线程转化为主协程；

开启协程（launch或async）时的操作的实际上是通过launch或async传入挂起函数的lambda表达式，其他三个传入参数都是默认参数，可以不用传入。



技能点:

1. 熟悉模版开发技术  jsp velocity freemarker
2. 掌握面向对象分析设计技术；
3. 熟悉多线程/多任务开发技术
4. 良好的归纳分析能力和文档编写能力
5. 对新事物有良好的接受能力，有良好的敬业精神和团队意识，学习能力较强
6. 熟练使用接口回调和函数式编程
7. 熟悉常用的设计模式
8. 熟悉并能设计简单的领域特定编程语言
9. 熟练使用gradle项目构建工具